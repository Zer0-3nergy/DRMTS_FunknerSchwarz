-- -------------------------------------------------------------
-- 
-- File Name: F:\MyGit_Folder\DRMTS_FunknerSchwarz\behav\VHDL\dsm_l2_sim_deci_cic_HDLgeneration\FIRPartlySerial_block2.vhd
-- Created: 2026-01-30 10:42:36
-- 
-- Generated by MATLAB 25.2, HDL Coder 25.2, and Simulink 25.2
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: FIRPartlySerial_block2
-- Source Path: dsm_l2_sim_deci_cic_HDLgeneration/DECIMATOR/HBF2/FIRPartlySerial
-- Hierarchy Level: 2
-- Model version: 17.88
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.DECIMATOR_pkg.ALL;

ENTITY FIRPartlySerial_block2 IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        filterInput                       :   IN    std_logic_vector(16 DOWNTO 0);  -- sfix17_En12
        ctrl                              :   IN    std_logic;
        subfilterOutTmp_2                 :   OUT   std_logic_vector(33 DOWNTO 0);  -- sfix34_En28
        subfilterOutTmp_vld2              :   OUT   std_logic
        );
END FIRPartlySerial_block2;


ARCHITECTURE rtl OF FIRPartlySerial_block2 IS

  -- Component Declarations
  COMPONENT FirRdyLogic_block2
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          dinSwitch                       :   IN    std_logic_vector(16 DOWNTO 0);  -- sfix17_En12
          dinVldSwitch                    :   IN    std_logic;
          coeff                           :   IN    std_logic_vector(16 DOWNTO 0);  -- sfix17_En12
          haltProcess                     :   IN    std_logic;
          dinSM                           :   OUT   std_logic_vector(16 DOWNTO 0);  -- sfix17_En12
          dinVldSM                        :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT Addressable_Delay_Line_block9
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          dataIn                          :   IN    std_logic_vector(16 DOWNTO 0);  -- sfix17_En12
          wrEn                            :   IN    std_logic;
          delayLineEnd                    :   OUT   std_logic_vector(16 DOWNTO 0)  -- sfix17_En12
          );
  END COMPONENT;

  COMPONENT Addressable_Delay_Line_block10
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          dataIn                          :   IN    std_logic_vector(16 DOWNTO 0);  -- sfix17_En12
          validIn                         :   IN    std_logic;
          rdAddr                          :   IN    std_logic;  -- ufix1
          dataOut                         :   OUT   std_logic_vector(16 DOWNTO 0)  -- sfix17_En12
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : FirRdyLogic_block2
    USE ENTITY work.FirRdyLogic_block2(rtl);

  FOR ALL : Addressable_Delay_Line_block9
    USE ENTITY work.Addressable_Delay_Line_block9(rtl);

  FOR ALL : Addressable_Delay_Line_block10
    USE ENTITY work.Addressable_Delay_Line_block10(rtl);

  -- Functions
  -- HDLCODER_TO_STDLOGIC 
  FUNCTION hdlcoder_to_stdlogic(arg: boolean) RETURN std_logic IS
  BEGIN
    IF arg THEN
      RETURN '1';
    ELSE
      RETURN '0';
    END IF;
  END FUNCTION;


  -- Signals
  SIGNAL coeff                            : signed(16 DOWNTO 0);  -- sfix17_En12
  SIGNAL haltProcess                      : std_logic;
  SIGNAL dinSM                            : std_logic_vector(16 DOWNTO 0);  -- ufix17
  SIGNAL dinVldSM                         : std_logic;
  SIGNAL nextDelayLineRdAddrReverse       : std_logic;  -- ufix1
  SIGNAL rdCountReverse_1                 : std_logic;  -- ufix1
  SIGNAL nextDelayLineWrAddr              : std_logic;  -- ufix1
  SIGNAL wrCount_1                        : std_logic;  -- ufix1
  SIGNAL nextDelayLineRdAddr              : std_logic;  -- ufix1
  SIGNAL rdCount_1                        : std_logic;  -- ufix1
  SIGNAL nextSharingCount                 : std_logic;  -- ufix1
  SIGNAL sharingCount_1                   : std_logic;  -- ufix1
  SIGNAL delayLineValidInP                : std_logic;
  SIGNAL lastPhaseStrobe                  : std_logic;
  SIGNAL delayLineShiftEnP                : std_logic;
  SIGNAL delayLineShiftEn1_1              : std_logic;
  SIGNAL delayLineShiftEn2_1              : std_logic;
  SIGNAL delayLineShiftEn3_1              : std_logic;
  SIGNAL delayLineShiftEn4_1              : std_logic;
  SIGNAL delayLineShiftEn5_1              : std_logic;
  SIGNAL delayLineShiftEn6_1              : std_logic;
  SIGNAL delayLineShiftEn7_1              : std_logic;
  SIGNAL validOutLookahead_reg            : std_logic_vector(6 DOWNTO 0);  -- ufix1 [7]
  SIGNAL validOutLookahead_1              : std_logic;
  SIGNAL vldOut_1                         : std_logic;
  SIGNAL notValid                         : std_logic;
  SIGNAL rdAddr0_1                        : std_logic;  -- ufix1
  SIGNAL rdAddr1                          : std_logic;  -- ufix1
  SIGNAL rdAddr2                          : std_logic;  -- ufix1
  SIGNAL rdAddr3                          : std_logic;  -- ufix1
  SIGNAL rdAddr4                          : std_logic;  -- ufix1
  SIGNAL rdAddr5                          : std_logic;  -- ufix1
  SIGNAL rdAddr6                          : std_logic;  -- ufix1
  SIGNAL rdAddr7                          : std_logic;  -- ufix1
  SIGNAL rdAddrEndZero                    : std_logic;
  SIGNAL finalSumValidPipe_reg            : std_logic_vector(5 DOWNTO 0);  -- ufix1 [6]
  SIGNAL accumulate                       : std_logic;
  SIGNAL accDataOut                       : signed(32 DOWNTO 0);  -- sfix33_En28
  SIGNAL coeffTableOut6                   : signed(16 DOWNTO 0);  -- sfix17_En16
  SIGNAL coeffTableRegP6_1                : signed(16 DOWNTO 0) := to_signed(16#00000#, 17);  -- sfix17_En16
  SIGNAL coeffTableReg6_1                 : signed(16 DOWNTO 0);  -- sfix17_En16
  SIGNAL coeffNonZero                     : std_logic;
  SIGNAL gainOut                          : signed(33 DOWNTO 0);  -- sfix34_En28
  SIGNAL delayLineEnd0                    : std_logic_vector(16 DOWNTO 0);  -- ufix17
  SIGNAL delayLineEnd0_signed             : signed(16 DOWNTO 0);  -- sfix17_En12
  SIGNAL delayLineDataIn1_1               : signed(16 DOWNTO 0);  -- sfix17_En12
  SIGNAL delayLineEnd1                    : std_logic_vector(16 DOWNTO 0);  -- ufix17
  SIGNAL delayLineEnd1_signed             : signed(16 DOWNTO 0);  -- sfix17_En12
  SIGNAL delayLineDataIn2_1               : signed(16 DOWNTO 0);  -- sfix17_En12
  SIGNAL delayLineEnd2                    : std_logic_vector(16 DOWNTO 0);  -- ufix17
  SIGNAL delayLineEnd2_signed             : signed(16 DOWNTO 0);  -- sfix17_En12
  SIGNAL delayLineDataIn3_1               : signed(16 DOWNTO 0);  -- sfix17_En12
  SIGNAL delayLineEnd3                    : std_logic_vector(16 DOWNTO 0);  -- ufix17
  SIGNAL delayLineEnd3_signed             : signed(16 DOWNTO 0);  -- sfix17_En12
  SIGNAL delayLineDataIn4_1               : signed(16 DOWNTO 0);  -- sfix17_En12
  SIGNAL delayLineEnd4                    : std_logic_vector(16 DOWNTO 0);  -- ufix17
  SIGNAL delayLineEnd4_signed             : signed(16 DOWNTO 0);  -- sfix17_En12
  SIGNAL delayLineDataIn5_1               : signed(16 DOWNTO 0);  -- sfix17_En12
  SIGNAL delayLineEnd5                    : std_logic_vector(16 DOWNTO 0);  -- ufix17
  SIGNAL delayLineEnd5_signed             : signed(16 DOWNTO 0);  -- sfix17_En12
  SIGNAL delayLineDataIn6_1               : signed(16 DOWNTO 0);  -- sfix17_En12
  SIGNAL delayLineDataOut6                : std_logic_vector(16 DOWNTO 0);  -- ufix17
  SIGNAL delayLineDataOut6_signed         : signed(16 DOWNTO 0);  -- sfix17_En12
  SIGNAL gainOut_1                        : signed(33 DOWNTO 0);  -- sfix34_En28
  SIGNAL gainOutDB                        : signed(33 DOWNTO 0);  -- sfix34_En28
  SIGNAL gainOutSwitch                    : signed(33 DOWNTO 0);  -- sfix34_En28
  SIGNAL filterDelay_reg                  : vector_of_signed34(0 TO 3);  -- sfix34 [4]
  SIGNAL gainOutREG                       : signed(33 DOWNTO 0);  -- sfix34_En28
  SIGNAL sumOut_5                         : signed(32 DOWNTO 0);  -- sfix33_En28
  SIGNAL sumOutReg_1                      : signed(32 DOWNTO 0);  -- sfix33_En28
  SIGNAL accDataOut_1                     : signed(32 DOWNTO 0);  -- sfix33_En28
  SIGNAL accSwitchOut                     : signed(32 DOWNTO 0);  -- sfix33_En28
  SIGNAL accAdderOut                      : signed(32 DOWNTO 0);  -- sfix33_En28
  SIGNAL converterOut                     : signed(33 DOWNTO 0);  -- sfix34_En28
  SIGNAL dout_re_1                        : signed(33 DOWNTO 0);  -- sfix34_En28
  SIGNAL dataZero                         : signed(33 DOWNTO 0);  -- sfix34_En28
  SIGNAL subfilterOutTmp_2_tmp            : signed(33 DOWNTO 0);  -- sfix34_En28

BEGIN
  u_firRdyLogic : FirRdyLogic_block2
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              dinSwitch => filterInput,  -- sfix17_En12
              dinVldSwitch => ctrl,
              coeff => std_logic_vector(coeff),  -- sfix17_En12
              haltProcess => haltProcess,
              dinSM => dinSM,  -- sfix17_En12
              dinVldSM => dinVldSM
              );

  u_delayLine0 : Addressable_Delay_Line_block9
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              dataIn => dinSM,  -- sfix17_En12
              wrEn => delayLineValidInP,
              delayLineEnd => delayLineEnd0  -- sfix17_En12
              );

  u_delayLine1 : Addressable_Delay_Line_block9
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              dataIn => std_logic_vector(delayLineDataIn1_1),  -- sfix17_En12
              wrEn => delayLineShiftEn1_1,
              delayLineEnd => delayLineEnd1  -- sfix17_En12
              );

  u_delayLine2 : Addressable_Delay_Line_block9
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              dataIn => std_logic_vector(delayLineDataIn2_1),  -- sfix17_En12
              wrEn => delayLineShiftEn2_1,
              delayLineEnd => delayLineEnd2  -- sfix17_En12
              );

  u_delayLine3 : Addressable_Delay_Line_block9
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              dataIn => std_logic_vector(delayLineDataIn3_1),  -- sfix17_En12
              wrEn => delayLineShiftEn3_1,
              delayLineEnd => delayLineEnd3  -- sfix17_En12
              );

  u_delayLine4 : Addressable_Delay_Line_block9
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              dataIn => std_logic_vector(delayLineDataIn4_1),  -- sfix17_En12
              wrEn => delayLineShiftEn4_1,
              delayLineEnd => delayLineEnd4  -- sfix17_En12
              );

  u_delayLine5 : Addressable_Delay_Line_block9
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              dataIn => std_logic_vector(delayLineDataIn5_1),  -- sfix17_En12
              wrEn => delayLineShiftEn5_1,
              delayLineEnd => delayLineEnd5  -- sfix17_En12
              );

  u_delayLine6 : Addressable_Delay_Line_block10
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              dataIn => std_logic_vector(delayLineDataIn6_1),  -- sfix17_En12
              validIn => delayLineShiftEn6_1,
              rdAddr => rdAddr6,  -- ufix1
              dataOut => delayLineDataOut6  -- sfix17_En12
              );

  coeff <= to_signed(16#00000#, 17);

  haltProcess <= '0';

  rdCountReverse_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      rdCountReverse_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        rdCountReverse_1 <= nextDelayLineRdAddrReverse;
      END IF;
    END IF;
  END PROCESS rdCountReverse_process;


  wrCount_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      wrCount_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        wrCount_1 <= nextDelayLineWrAddr;
      END IF;
    END IF;
  END PROCESS wrCount_process;


  rdCount_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      rdCount_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        rdCount_1 <= nextDelayLineRdAddr;
      END IF;
    END IF;
  END PROCESS rdCount_process;


  sharingCount_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      sharingCount_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        sharingCount_1 <= nextSharingCount;
      END IF;
    END IF;
  END PROCESS sharingCount_process;


  -- Input control counter combinatorial logic
  InputControl_output : PROCESS (dinVldSM, rdCountReverse_1, rdCount_1, sharingCount_1, wrCount_1)
    VARIABLE out4 : std_logic;
    VARIABLE add_cast : unsigned(1 DOWNTO 0);
    VARIABLE add_temp : unsigned(1 DOWNTO 0);
    VARIABLE add_cast_0 : unsigned(1 DOWNTO 0);
    VARIABLE add_temp_0 : unsigned(1 DOWNTO 0);
    VARIABLE sub_cast : unsigned(1 DOWNTO 0);
    VARIABLE sub_temp : unsigned(1 DOWNTO 0);
    VARIABLE add_cast_1 : unsigned(1 DOWNTO 0);
    VARIABLE add_temp_1 : unsigned(1 DOWNTO 0);
    VARIABLE add_cast_2 : unsigned(1 DOWNTO 0);
    VARIABLE add_temp_2 : unsigned(1 DOWNTO 0);
  BEGIN
    add_temp := to_unsigned(16#0#, 2);
    add_temp_0 := to_unsigned(16#0#, 2);
    sub_temp := to_unsigned(16#0#, 2);
    add_temp_1 := to_unsigned(16#0#, 2);
    add_temp_2 := to_unsigned(16#0#, 2);
    add_cast_2 := to_unsigned(16#0#, 2);
    add_cast_1 := to_unsigned(16#0#, 2);
    sub_cast := to_unsigned(16#0#, 2);
    add_cast_0 := to_unsigned(16#0#, 2);
    add_cast := to_unsigned(16#0#, 2);
    delayLineValidInP <= hdlcoder_to_stdlogic((sharingCount_1 = '0') AND (dinVldSM = '1'));
    lastPhaseStrobe <= sharingCount_1;
    IF (dinVldSM = '1') OR (sharingCount_1 > '0') THEN 
      IF sharingCount_1 = '1' THEN 
        nextSharingCount <= '0';
      ELSE 
        add_cast := '0' & sharingCount_1;
        add_temp := add_cast + to_unsigned(16#1#, 2);
        nextSharingCount <= add_temp(0);
      END IF;
    ELSE 
      nextSharingCount <= sharingCount_1;
    END IF;
    IF dinVldSM = '1' THEN 
      IF wrCount_1 = '1' THEN 
        out4 := '0';
      ELSE 
        add_cast_0 := '0' & wrCount_1;
        add_temp_0 := add_cast_0 + to_unsigned(16#1#, 2);
        out4 := add_temp_0(0);
      END IF;
    ELSE 
      out4 := wrCount_1;
    END IF;
    IF (rdCount_1 /= out4) OR (dinVldSM = '1') THEN 
      IF rdCount_1 = '0' THEN 
        nextDelayLineRdAddr <= '1';
      ELSE 
        sub_cast := '0' & rdCount_1;
        sub_temp := sub_cast - to_unsigned(16#1#, 2);
        nextDelayLineRdAddr <= sub_temp(0);
      END IF;
    ELSE 
      nextDelayLineRdAddr <= rdCount_1;
    END IF;
    IF (sharingCount_1 > '0') OR (dinVldSM = '1') THEN 
      IF sharingCount_1 = '1' THEN 
        IF wrCount_1 = '1' THEN 
          nextDelayLineRdAddrReverse <= '0';
        ELSE 
          add_cast_2 := '0' & wrCount_1;
          add_temp_2 := add_cast_2 + to_unsigned(16#1#, 2);
          nextDelayLineRdAddrReverse <= add_temp_2(0);
        END IF;
      ELSIF rdCountReverse_1 = '1' THEN 
        nextDelayLineRdAddrReverse <= '0';
      ELSE 
        add_cast_1 := '0' & rdCountReverse_1;
        add_temp_1 := add_cast_1 + to_unsigned(16#1#, 2);
        nextDelayLineRdAddrReverse <= add_temp_1(0);
      END IF;
    ELSE 
      nextDelayLineRdAddrReverse <= rdCountReverse_1;
    END IF;
    nextDelayLineWrAddr <= out4;
  END PROCESS InputControl_output;


  delayLineShiftEn0_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayLineShiftEnP <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayLineShiftEnP <= lastPhaseStrobe;
      END IF;
    END IF;
  END PROCESS delayLineShiftEn0_process;


  delayLineShiftEn1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayLineShiftEn1_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayLineShiftEn1_1 <= delayLineShiftEnP;
      END IF;
    END IF;
  END PROCESS delayLineShiftEn1_process;


  delayLineShiftEn2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayLineShiftEn2_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayLineShiftEn2_1 <= delayLineShiftEn1_1;
      END IF;
    END IF;
  END PROCESS delayLineShiftEn2_process;


  delayLineShiftEn3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayLineShiftEn3_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayLineShiftEn3_1 <= delayLineShiftEn2_1;
      END IF;
    END IF;
  END PROCESS delayLineShiftEn3_process;


  delayLineShiftEn4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayLineShiftEn4_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayLineShiftEn4_1 <= delayLineShiftEn3_1;
      END IF;
    END IF;
  END PROCESS delayLineShiftEn4_process;


  delayLineShiftEn5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayLineShiftEn5_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayLineShiftEn5_1 <= delayLineShiftEn4_1;
      END IF;
    END IF;
  END PROCESS delayLineShiftEn5_process;


  delayLineShiftEn6_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayLineShiftEn6_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayLineShiftEn6_1 <= delayLineShiftEn5_1;
      END IF;
    END IF;
  END PROCESS delayLineShiftEn6_process;


  delayLineShiftEn7_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayLineShiftEn7_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayLineShiftEn7_1 <= delayLineShiftEn6_1;
      END IF;
    END IF;
  END PROCESS delayLineShiftEn7_process;


  validOutLookahead_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      validOutLookahead_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        validOutLookahead_reg(0) <= delayLineShiftEn7_1;
        validOutLookahead_reg(6 DOWNTO 1) <= validOutLookahead_reg(5 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS validOutLookahead_process;

  validOutLookahead_1 <= validOutLookahead_reg(6);

  vldOut_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      vldOut_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        vldOut_1 <= validOutLookahead_1;
      END IF;
    END IF;
  END PROCESS vldOut_process;


  notValid <=  NOT vldOut_1;

  rdAddr0_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      rdAddr0_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        rdAddr0_1 <= sharingCount_1;
      END IF;
    END IF;
  END PROCESS rdAddr0_process;


  rdAddr0_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      rdAddr1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        rdAddr1 <= rdAddr0_1;
      END IF;
    END IF;
  END PROCESS rdAddr0_2_process;


  rdAddr1_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      rdAddr2 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        rdAddr2 <= rdAddr1;
      END IF;
    END IF;
  END PROCESS rdAddr1_1_process;


  rdAddr2_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      rdAddr3 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        rdAddr3 <= rdAddr2;
      END IF;
    END IF;
  END PROCESS rdAddr2_1_process;


  rdAddr3_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      rdAddr4 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        rdAddr4 <= rdAddr3;
      END IF;
    END IF;
  END PROCESS rdAddr3_1_process;


  rdAddr4_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      rdAddr5 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        rdAddr5 <= rdAddr4;
      END IF;
    END IF;
  END PROCESS rdAddr4_1_process;


  rdAddr5_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      rdAddr6 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        rdAddr6 <= rdAddr5;
      END IF;
    END IF;
  END PROCESS rdAddr5_1_process;


  rdAddr6_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      rdAddr7 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        rdAddr7 <= rdAddr6;
      END IF;
    END IF;
  END PROCESS rdAddr6_1_process;


  rdAddrEndZero <=  NOT rdAddr7;

  finalSumValidPipe_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      finalSumValidPipe_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        finalSumValidPipe_reg(0) <= rdAddrEndZero;
        finalSumValidPipe_reg(5 DOWNTO 1) <= finalSumValidPipe_reg(4 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS finalSumValidPipe_process;

  accumulate <= finalSumValidPipe_reg(5);

  accDataOut <= to_signed(0, 33);

  -- Coefficient table for multiplier6
  coeffTable6_output : PROCESS (rdAddr6)
  BEGIN
    CASE rdAddr6 IS
      WHEN '0' =>
        coeffTableOut6 <= to_signed(16#08000#, 17);
      WHEN '1' =>
        coeffTableOut6 <= to_signed(16#00000#, 17);
      WHEN OTHERS => 
        coeffTableOut6 <= to_signed(16#00000#, 17);
    END CASE;
  END PROCESS coeffTable6_output;


  coeffTableRegP6_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        coeffTableRegP6_1 <= coeffTableOut6;
      END IF;
    END IF;
  END PROCESS coeffTableRegP6_process;


  coeffTableReg6_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      coeffTableReg6_1 <= to_signed(16#00000#, 17);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        coeffTableReg6_1 <= coeffTableRegP6_1;
      END IF;
    END IF;
  END PROCESS coeffTableReg6_process;


  
  coeffNonZero <= '1' WHEN coeffTableReg6_1 /= to_signed(16#00000#, 17) ELSE
      '0';

  gainOut <= to_signed(0, 34);

  delayLineEnd0_signed <= signed(delayLineEnd0);

  delayLineDataIn1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayLineDataIn1_1 <= to_signed(16#00000#, 17);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayLineDataIn1_1 <= delayLineEnd0_signed;
      END IF;
    END IF;
  END PROCESS delayLineDataIn1_process;


  delayLineEnd1_signed <= signed(delayLineEnd1);

  delayLineDataIn2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayLineDataIn2_1 <= to_signed(16#00000#, 17);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayLineDataIn2_1 <= delayLineEnd1_signed;
      END IF;
    END IF;
  END PROCESS delayLineDataIn2_process;


  delayLineEnd2_signed <= signed(delayLineEnd2);

  delayLineDataIn3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayLineDataIn3_1 <= to_signed(16#00000#, 17);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayLineDataIn3_1 <= delayLineEnd2_signed;
      END IF;
    END IF;
  END PROCESS delayLineDataIn3_process;


  delayLineEnd3_signed <= signed(delayLineEnd3);

  delayLineDataIn4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayLineDataIn4_1 <= to_signed(16#00000#, 17);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayLineDataIn4_1 <= delayLineEnd3_signed;
      END IF;
    END IF;
  END PROCESS delayLineDataIn4_process;


  delayLineEnd4_signed <= signed(delayLineEnd4);

  delayLineDataIn5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayLineDataIn5_1 <= to_signed(16#00000#, 17);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayLineDataIn5_1 <= delayLineEnd4_signed;
      END IF;
    END IF;
  END PROCESS delayLineDataIn5_process;


  delayLineEnd5_signed <= signed(delayLineEnd5);

  delayLineDataIn6_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayLineDataIn6_1 <= to_signed(16#00000#, 17);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayLineDataIn6_1 <= delayLineEnd5_signed;
      END IF;
    END IF;
  END PROCESS delayLineDataIn6_process;


  delayLineDataOut6_signed <= signed(delayLineDataOut6);

  gainOut_1 <= resize(delayLineDataOut6_signed & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 34);

  filterDelay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      gainOutDB <= to_signed(0, 34);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        gainOutDB <= gainOut_1;
      END IF;
    END IF;
  END PROCESS filterDelay_process;


  
  gainOutSwitch <= gainOut WHEN coeffNonZero = '0' ELSE
      gainOutDB;

  filterDelay_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      filterDelay_reg <= (OTHERS => to_signed(0, 34));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        filterDelay_reg(0) <= gainOutSwitch;
        filterDelay_reg(1 TO 3) <= filterDelay_reg(0 TO 2);
      END IF;
    END IF;
  END PROCESS filterDelay_1_process;

  gainOutREG <= filterDelay_reg(3);

  sumOut_5 <= gainOutREG(32 DOWNTO 0);

  sumOutReg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      sumOutReg_1 <= to_signed(0, 33);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        sumOutReg_1 <= sumOut_5;
      END IF;
    END IF;
  END PROCESS sumOutReg_process;


  
  accSwitchOut <= accDataOut_1 WHEN accumulate = '0' ELSE
      accDataOut;

  accAdderOut <= accSwitchOut + sumOutReg_1;

  accDataOut_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      accDataOut_1 <= to_signed(0, 33);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        accDataOut_1 <= accAdderOut;
      END IF;
    END IF;
  END PROCESS accDataOut_2_process;


  converterOut <= resize(accDataOut_1, 34);

  dout_re_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      dout_re_1 <= to_signed(0, 34);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' AND validOutLookahead_1 = '1' THEN
        dout_re_1 <= converterOut;
      END IF;
    END IF;
  END PROCESS dout_re_process;


  dataZero <= to_signed(0, 34);

  
  subfilterOutTmp_2_tmp <= dout_re_1 WHEN notValid = '0' ELSE
      dataZero;

  subfilterOutTmp_2 <= std_logic_vector(subfilterOutTmp_2_tmp);

  subfilterOutTmp_vld2 <= vldOut_1;

END rtl;

