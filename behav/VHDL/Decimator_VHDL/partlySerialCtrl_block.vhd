-- -------------------------------------------------------------
-- 
-- File Name: F:\MyGit_Folder\DRMTS_FunknerSchwarz\behav\VHDL\dsm_l2_sim_deci_cic_HDLgeneration\partlySerialCtrl_block.vhd
-- Created: 2026-01-30 11:58:51
-- 
-- Generated by MATLAB 25.2, HDL Coder 25.2, and Simulink 25.2
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: partlySerialCtrl_block
-- Source Path: dsm_l2_sim_deci_cic_HDLgeneration/DECIMATOR/HBF2/partlySerialCtrl
-- Hierarchy Level: 2
-- Model version: 17.90
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY partlySerialCtrl_block IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        validIn                           :   IN    std_logic;
        ctrl                              :   OUT   std_logic;
        ready                             :   OUT   std_logic
        );
END partlySerialCtrl_block;


ARCHITECTURE rtl OF partlySerialCtrl_block IS

  -- Signals
  SIGNAL CtrlLogic_inputCnt               : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL CtrlLogic_state                  : std_logic;  -- ufix1
  SIGNAL CtrlLogic_vldOutReg              : std_logic;
  SIGNAL CtrlLogic_rdyReg                 : std_logic;
  SIGNAL CtrlLogic_inputCnt_next          : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL CtrlLogic_state_next             : std_logic;  -- ufix1
  SIGNAL CtrlLogic_vldOutReg_next         : std_logic;
  SIGNAL CtrlLogic_rdyReg_next            : std_logic;

BEGIN
  -- CtrlLogic
  CtrlLogic_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      CtrlLogic_inputCnt <= to_unsigned(16#0#, 2);
      CtrlLogic_state <= '0';
      CtrlLogic_vldOutReg <= '0';
      CtrlLogic_rdyReg <= '1';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        CtrlLogic_inputCnt <= CtrlLogic_inputCnt_next;
        CtrlLogic_state <= CtrlLogic_state_next;
        CtrlLogic_vldOutReg <= CtrlLogic_vldOutReg_next;
        CtrlLogic_rdyReg <= CtrlLogic_rdyReg_next;
      END IF;
    END IF;
  END PROCESS CtrlLogic_process;

  CtrlLogic_output : PROCESS (CtrlLogic_inputCnt, CtrlLogic_rdyReg, CtrlLogic_state, CtrlLogic_vldOutReg,
       validIn)
  BEGIN
    CtrlLogic_inputCnt_next <= CtrlLogic_inputCnt;
    CASE CtrlLogic_state IS
      WHEN '0' =>
        CtrlLogic_state_next <= '0';
        CtrlLogic_inputCnt_next <= to_unsigned(16#0#, 2);
        CtrlLogic_vldOutReg_next <= '0';
        IF (validIn AND CtrlLogic_rdyReg) = '1' THEN 
          CtrlLogic_state_next <= '1';
          CtrlLogic_inputCnt_next <= to_unsigned(16#1#, 2);
        END IF;
      WHEN '1' =>
        CtrlLogic_state_next <= '1';
        CtrlLogic_vldOutReg_next <= '0';
        IF (validIn AND CtrlLogic_rdyReg) = '1' THEN 
          IF CtrlLogic_inputCnt = to_unsigned(16#1#, 2) THEN 
            CtrlLogic_vldOutReg_next <= '1';
            CtrlLogic_inputCnt_next <= to_unsigned(16#0#, 2);
            CtrlLogic_state_next <= '0';
          ELSE 
            CtrlLogic_inputCnt_next <= CtrlLogic_inputCnt + to_unsigned(16#1#, 2);
          END IF;
        END IF;
      WHEN OTHERS => 
        CtrlLogic_state_next <= '0';
        CtrlLogic_inputCnt_next <= to_unsigned(16#0#, 2);
        CtrlLogic_vldOutReg_next <= '0';
    END CASE;
    CtrlLogic_rdyReg_next <= '1';
    ctrl <= CtrlLogic_vldOutReg;
    ready <= CtrlLogic_rdyReg;
  END PROCESS CtrlLogic_output;


END rtl;

