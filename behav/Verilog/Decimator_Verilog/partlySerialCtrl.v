// -------------------------------------------------------------
// 
// File Name: F:\MyGit_Folder\DRMTS_FunknerSchwarz\behav\Verilog\dsm_l2_sim_deci_cic_HDLgeneration\partlySerialCtrl.v
// Created: 2026-01-30 11:58:04
// 
// Generated by MATLAB 25.2, HDL Coder 25.2, and Simulink 25.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: partlySerialCtrl
// Source Path: dsm_l2_sim_deci_cic_HDLgeneration/DECIMATOR/HBF1/partlySerialCtrl
// Hierarchy Level: 2
// Model version: 17.90
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module partlySerialCtrl
          (clk,
           reset,
           enb,
           validIn,
           ctrl,
           ready);


  input   clk;
  input   reset;
  input   enb;
  input   validIn;
  output  ctrl;
  output  ready;


  reg [1:0] CtrlLogic_inputCnt;  // ufix2
  reg  CtrlLogic_state;  // ufix1
  reg  CtrlLogic_vldOutReg;
  reg  CtrlLogic_rdyReg;
  reg [1:0] CtrlLogic_inputCnt_next;  // ufix2
  reg  CtrlLogic_state_next;  // ufix1
  reg  CtrlLogic_vldOutReg_next;
  reg  CtrlLogic_rdyReg_next;
  reg  ctrl_1;
  reg  ready_1;


  // CtrlLogic
  always @(posedge clk or posedge reset)
    begin : CtrlLogic_process
      if (reset == 1'b1) begin
        CtrlLogic_inputCnt <= 2'b00;
        CtrlLogic_state <= 1'b0;
        CtrlLogic_vldOutReg <= 1'b0;
        CtrlLogic_rdyReg <= 1'b1;
      end
      else begin
        if (enb) begin
          CtrlLogic_inputCnt <= CtrlLogic_inputCnt_next;
          CtrlLogic_state <= CtrlLogic_state_next;
          CtrlLogic_vldOutReg <= CtrlLogic_vldOutReg_next;
          CtrlLogic_rdyReg <= CtrlLogic_rdyReg_next;
        end
      end
    end

  always @(CtrlLogic_inputCnt, CtrlLogic_rdyReg, CtrlLogic_state, CtrlLogic_vldOutReg,
       validIn) begin
    CtrlLogic_inputCnt_next = CtrlLogic_inputCnt;
    case ( CtrlLogic_state)
      1'b0 :
        begin
          CtrlLogic_state_next = 1'b0;
          CtrlLogic_inputCnt_next = 2'b00;
          CtrlLogic_vldOutReg_next = 1'b0;
          if (validIn && CtrlLogic_rdyReg) begin
            CtrlLogic_state_next = 1'b1;
            CtrlLogic_inputCnt_next = 2'b01;
          end
        end
      1'b1 :
        begin
          CtrlLogic_state_next = 1'b1;
          CtrlLogic_vldOutReg_next = 1'b0;
          if (validIn && CtrlLogic_rdyReg) begin
            if (CtrlLogic_inputCnt == 2'b01) begin
              CtrlLogic_vldOutReg_next = 1'b1;
              CtrlLogic_inputCnt_next = 2'b00;
              CtrlLogic_state_next = 1'b0;
            end
            else begin
              CtrlLogic_inputCnt_next = CtrlLogic_inputCnt + 2'b01;
            end
          end
        end
      default :
        begin
          CtrlLogic_state_next = 1'b0;
          CtrlLogic_inputCnt_next = 2'b00;
          CtrlLogic_vldOutReg_next = 1'b0;
        end
    endcase
    CtrlLogic_rdyReg_next = 1'b1;
    ctrl_1 = CtrlLogic_vldOutReg;
    ready_1 = CtrlLogic_rdyReg;
  end

  assign ctrl = ctrl_1;

  assign ready = ready_1;

endmodule  // partlySerialCtrl

