// -------------------------------------------------------------
// 
// File Name: F:\MyGit_Folder\DRMTS_FunknerSchwarz\behav\Verilog\dsm_l2_sim_deci_cic_HDLgeneration\FIRPartlySerial_block2.v
// Created: 2026-01-30 10:39:16
// 
// Generated by MATLAB 25.2, HDL Coder 25.2, and Simulink 25.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: FIRPartlySerial_block2
// Source Path: dsm_l2_sim_deci_cic_HDLgeneration/DECIMATOR/HBF2/FIRPartlySerial
// Hierarchy Level: 2
// Model version: 17.87
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module FIRPartlySerial_block2
          (clk,
           reset,
           enb,
           filterInput,
           ctrl,
           subfilterOutTmp_2,
           subfilterOutTmp_vld2);


  input   clk;
  input   reset;
  input   enb;
  input   signed [16:0] filterInput;  // sfix17_En12
  input   ctrl;
  output  signed [33:0] subfilterOutTmp_2;  // sfix34_En28
  output  subfilterOutTmp_vld2;


  wire signed [16:0] coeff;  // sfix17_En12
  wire haltProcess;
  wire signed [16:0] dinSM;  // sfix17_En12
  wire dinVldSM;
  reg  nextDelayLineRdAddrReverse;  // ufix1
  reg  rdCountReverse_1;  // ufix1
  reg  nextDelayLineWrAddr;  // ufix1
  reg  wrCount_1;  // ufix1
  reg  nextDelayLineRdAddr;  // ufix1
  reg  rdCount_1;  // ufix1
  reg  nextSharingCount;  // ufix1
  reg  sharingCount_1;  // ufix1
  reg  delayLineValidInP;
  reg  lastPhaseStrobe;
  reg  delayLineShiftEnP;
  reg  delayLineShiftEn1_1;
  reg  delayLineShiftEn2_1;
  reg  delayLineShiftEn3_1;
  reg  delayLineShiftEn4_1;
  reg  delayLineShiftEn5_1;
  reg  delayLineShiftEn6_1;
  reg  delayLineShiftEn7_1;
  reg  [6:0] validOutLookahead_reg;  // ufix1 [7]
  wire validOutLookahead_1;
  reg  vldOut_1;
  wire notValid;
  reg  rdAddr0_1;  // ufix1
  reg  rdAddr1;  // ufix1
  reg  rdAddr2;  // ufix1
  reg  rdAddr3;  // ufix1
  reg  rdAddr4;  // ufix1
  reg  rdAddr5;  // ufix1
  reg  rdAddr6;  // ufix1
  reg  rdAddr7;  // ufix1
  wire rdAddrEndZero;
  reg  [5:0] finalSumValidPipe_reg;  // ufix1 [6]
  wire accumulate;
  wire signed [32:0] accDataOut;  // sfix33_En28
  reg signed [16:0] coeffTableOut6;  // sfix17_En16
  reg signed [16:0] coeffTableRegP6_1;  // sfix17_En16
  reg signed [16:0] coeffTableReg6_1;  // sfix17_En16
  wire coeffNonZero;
  wire signed [33:0] gainOut;  // sfix34_En28
  wire signed [16:0] delayLineEnd0;  // sfix17_En12
  reg signed [16:0] delayLineDataIn1_1;  // sfix17_En12
  wire signed [16:0] delayLineEnd1;  // sfix17_En12
  reg signed [16:0] delayLineDataIn2_1;  // sfix17_En12
  wire signed [16:0] delayLineEnd2;  // sfix17_En12
  reg signed [16:0] delayLineDataIn3_1;  // sfix17_En12
  wire signed [16:0] delayLineEnd3;  // sfix17_En12
  reg signed [16:0] delayLineDataIn4_1;  // sfix17_En12
  wire signed [16:0] delayLineEnd4;  // sfix17_En12
  reg signed [16:0] delayLineDataIn5_1;  // sfix17_En12
  wire signed [16:0] delayLineEnd5;  // sfix17_En12
  reg signed [16:0] delayLineDataIn6_1;  // sfix17_En12
  wire signed [16:0] delayLineDataOut6;  // sfix17_En12
  wire signed [33:0] gainOut_1;  // sfix34_En28
  reg signed [33:0] gainOutDB;  // sfix34_En28
  wire signed [33:0] gainOutSwitch;  // sfix34_En28
  reg signed [33:0] filterDelay_reg [0:3];  // sfix34 [4]
  reg signed [33:0] filterDelay_reg_next [0:3];  // sfix34_En28 [4]
  reg signed [33:0] gainOutREG;  // sfix34_En28
  wire signed [32:0] sumOut_5;  // sfix33_En28
  reg signed [32:0] sumOutReg_1;  // sfix33_En28
  reg signed [32:0] accDataOut_1;  // sfix33_En28
  wire signed [32:0] accSwitchOut;  // sfix33_En28
  wire signed [32:0] accAdderOut;  // sfix33_En28
  wire signed [33:0] converterOut;  // sfix34_En28
  reg signed [33:0] dout_re_1;  // sfix34_En28
  wire signed [33:0] dataZero;  // sfix34_En28
  reg  InputControl_out4_0;  // ufix1
  reg [1:0] InputControl_add_temp;  // ufix2
  reg [1:0] InputControl_add_temp_0;  // ufix2
  reg [1:0] InputControl_sub_temp;  // ufix2
  reg [1:0] InputControl_add_temp_1;  // ufix2
  reg [1:0] InputControl_add_temp_2;  // ufix2
  reg [1:0] InputControl_t_0_0;  // ufix2
  reg [1:0] InputControl_t_1;  // ufix2
  reg [1:0] InputControl_t_2_0;  // ufix2
  reg [1:0] InputControl_t_3;  // ufix2
  reg [1:0] InputControl_t_4;  // ufix2
  reg signed [31:0] filterDelay_t_0_0;  // int32
  reg signed [31:0] filterDelay_t_0_1;  // int32
  reg signed [31:0] filterDelay_t_1;  // int32

  initial begin
    coeffTableRegP6_1 = 17'sb00000000000000000;
  end

  assign coeff = 17'sb00000000000000000;

  assign haltProcess = 1'b0;

  FirRdyLogic_block2 u_firRdyLogic (.clk(clk),
                                    .reset(reset),
                                    .enb(enb),
                                    .dinSwitch(filterInput),  // sfix17_En12
                                    .dinVldSwitch(ctrl),
                                    .coeff(coeff),  // sfix17_En12
                                    .haltProcess(haltProcess),
                                    .dinSM(dinSM),  // sfix17_En12
                                    .dinVldSM(dinVldSM)
                                    );

  always @(posedge clk or posedge reset)
    begin : rdCountReverse_process
      if (reset == 1'b1) begin
        rdCountReverse_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          rdCountReverse_1 <= nextDelayLineRdAddrReverse;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : wrCount_process
      if (reset == 1'b1) begin
        wrCount_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          wrCount_1 <= nextDelayLineWrAddr;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : rdCount_process
      if (reset == 1'b1) begin
        rdCount_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          rdCount_1 <= nextDelayLineRdAddr;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : sharingCount_process
      if (reset == 1'b1) begin
        sharingCount_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          sharingCount_1 <= nextSharingCount;
        end
      end
    end

  // Input control counter combinatorial logic
  always @(dinVldSM, rdCountReverse_1, rdCount_1, sharingCount_1, wrCount_1) begin
    InputControl_add_temp = 2'b00;
    InputControl_add_temp_0 = 2'b00;
    InputControl_sub_temp = 2'b00;
    InputControl_add_temp_1 = 2'b00;
    InputControl_add_temp_2 = 2'b00;
    InputControl_t_0_0 = 2'b00;
    InputControl_t_1 = 2'b00;
    InputControl_t_2_0 = 2'b00;
    InputControl_t_3 = 2'b00;
    InputControl_t_4 = 2'b00;
    delayLineValidInP = (sharingCount_1 == 1'b0) && (dinVldSM == 1'b1);
    lastPhaseStrobe = sharingCount_1 == 1'b1;
    if ((dinVldSM == 1'b1) || (sharingCount_1 > 1'b0)) begin
      if (sharingCount_1 == 1'b1) begin
        nextSharingCount = 1'b0;
      end
      else begin
        InputControl_t_4 = {1'b0, sharingCount_1};
        InputControl_add_temp = InputControl_t_4 + 2'b01;
        nextSharingCount = InputControl_add_temp[0];
      end
    end
    else begin
      nextSharingCount = sharingCount_1;
    end
    if (dinVldSM == 1'b1) begin
      if (wrCount_1 == 1'b1) begin
        InputControl_out4_0 = 1'b0;
      end
      else begin
        InputControl_t_3 = {1'b0, wrCount_1};
        InputControl_add_temp_0 = InputControl_t_3 + 2'b01;
        InputControl_out4_0 = InputControl_add_temp_0[0];
      end
    end
    else begin
      InputControl_out4_0 = wrCount_1;
    end
    if ((rdCount_1 != InputControl_out4_0) || (dinVldSM == 1'b1)) begin
      if (rdCount_1 == 1'b0) begin
        nextDelayLineRdAddr = 1'b1;
      end
      else begin
        InputControl_t_2_0 = {1'b0, rdCount_1};
        InputControl_sub_temp = InputControl_t_2_0 - 2'b01;
        nextDelayLineRdAddr = InputControl_sub_temp[0];
      end
    end
    else begin
      nextDelayLineRdAddr = rdCount_1;
    end
    if ((sharingCount_1 > 1'b0) || (dinVldSM == 1'b1)) begin
      if (sharingCount_1 == 1'b1) begin
        if (wrCount_1 == 1'b1) begin
          nextDelayLineRdAddrReverse = 1'b0;
        end
        else begin
          InputControl_t_0_0 = {1'b0, wrCount_1};
          InputControl_add_temp_2 = InputControl_t_0_0 + 2'b01;
          nextDelayLineRdAddrReverse = InputControl_add_temp_2[0];
        end
      end
      else if (rdCountReverse_1 == 1'b1) begin
        nextDelayLineRdAddrReverse = 1'b0;
      end
      else begin
        InputControl_t_1 = {1'b0, rdCountReverse_1};
        InputControl_add_temp_1 = InputControl_t_1 + 2'b01;
        nextDelayLineRdAddrReverse = InputControl_add_temp_1[0];
      end
    end
    else begin
      nextDelayLineRdAddrReverse = rdCountReverse_1;
    end
    nextDelayLineWrAddr = InputControl_out4_0;
  end

  always @(posedge clk or posedge reset)
    begin : delayLineShiftEn0_process
      if (reset == 1'b1) begin
        delayLineShiftEnP <= 1'b0;
      end
      else begin
        if (enb) begin
          delayLineShiftEnP <= lastPhaseStrobe;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : delayLineShiftEn1_process
      if (reset == 1'b1) begin
        delayLineShiftEn1_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          delayLineShiftEn1_1 <= delayLineShiftEnP;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : delayLineShiftEn2_process
      if (reset == 1'b1) begin
        delayLineShiftEn2_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          delayLineShiftEn2_1 <= delayLineShiftEn1_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : delayLineShiftEn3_process
      if (reset == 1'b1) begin
        delayLineShiftEn3_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          delayLineShiftEn3_1 <= delayLineShiftEn2_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : delayLineShiftEn4_process
      if (reset == 1'b1) begin
        delayLineShiftEn4_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          delayLineShiftEn4_1 <= delayLineShiftEn3_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : delayLineShiftEn5_process
      if (reset == 1'b1) begin
        delayLineShiftEn5_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          delayLineShiftEn5_1 <= delayLineShiftEn4_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : delayLineShiftEn6_process
      if (reset == 1'b1) begin
        delayLineShiftEn6_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          delayLineShiftEn6_1 <= delayLineShiftEn5_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : delayLineShiftEn7_process
      if (reset == 1'b1) begin
        delayLineShiftEn7_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          delayLineShiftEn7_1 <= delayLineShiftEn6_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : validOutLookahead_process
      if (reset == 1'b1) begin
        validOutLookahead_reg <= {7{1'b0}};
      end
      else begin
        if (enb) begin
          validOutLookahead_reg[0] <= delayLineShiftEn7_1;
          validOutLookahead_reg[32'sd6:32'sd1] <= validOutLookahead_reg[32'sd5:32'sd0];
        end
      end
    end

  assign validOutLookahead_1 = validOutLookahead_reg[6];

  always @(posedge clk or posedge reset)
    begin : vldOut_process
      if (reset == 1'b1) begin
        vldOut_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          vldOut_1 <= validOutLookahead_1;
        end
      end
    end

  assign notValid =  ~ vldOut_1;

  always @(posedge clk or posedge reset)
    begin : rdAddr0_process
      if (reset == 1'b1) begin
        rdAddr0_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          rdAddr0_1 <= sharingCount_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : rdAddr0_2_process
      if (reset == 1'b1) begin
        rdAddr1 <= 1'b0;
      end
      else begin
        if (enb) begin
          rdAddr1 <= rdAddr0_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : rdAddr1_1_process
      if (reset == 1'b1) begin
        rdAddr2 <= 1'b0;
      end
      else begin
        if (enb) begin
          rdAddr2 <= rdAddr1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : rdAddr2_1_process
      if (reset == 1'b1) begin
        rdAddr3 <= 1'b0;
      end
      else begin
        if (enb) begin
          rdAddr3 <= rdAddr2;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : rdAddr3_1_process
      if (reset == 1'b1) begin
        rdAddr4 <= 1'b0;
      end
      else begin
        if (enb) begin
          rdAddr4 <= rdAddr3;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : rdAddr4_1_process
      if (reset == 1'b1) begin
        rdAddr5 <= 1'b0;
      end
      else begin
        if (enb) begin
          rdAddr5 <= rdAddr4;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : rdAddr5_1_process
      if (reset == 1'b1) begin
        rdAddr6 <= 1'b0;
      end
      else begin
        if (enb) begin
          rdAddr6 <= rdAddr5;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : rdAddr6_1_process
      if (reset == 1'b1) begin
        rdAddr7 <= 1'b0;
      end
      else begin
        if (enb) begin
          rdAddr7 <= rdAddr6;
        end
      end
    end

  assign rdAddrEndZero =  ~ rdAddr7;

  always @(posedge clk or posedge reset)
    begin : finalSumValidPipe_process
      if (reset == 1'b1) begin
        finalSumValidPipe_reg <= {6{1'b0}};
      end
      else begin
        if (enb) begin
          finalSumValidPipe_reg[0] <= rdAddrEndZero;
          finalSumValidPipe_reg[32'sd5:32'sd1] <= finalSumValidPipe_reg[32'sd4:32'sd0];
        end
      end
    end

  assign accumulate = finalSumValidPipe_reg[5];

  assign accDataOut = 33'sh000000000;

  // Coefficient table for multiplier6
  always @(rdAddr6) begin
    case ( rdAddr6)
      1'b0 :
        begin
          coeffTableOut6 = 17'sb01000000000000000;
        end
      1'b1 :
        begin
          coeffTableOut6 = 17'sb00000000000000000;
        end
      default :
        begin
          coeffTableOut6 = 17'sb00000000000000000;
        end
    endcase
  end

  always @(posedge clk)
    begin : coeffTableRegP6_process
      if (enb) begin
        coeffTableRegP6_1 <= coeffTableOut6;
      end
    end

  always @(posedge clk or posedge reset)
    begin : coeffTableReg6_process
      if (reset == 1'b1) begin
        coeffTableReg6_1 <= 17'sb00000000000000000;
      end
      else begin
        if (enb) begin
          coeffTableReg6_1 <= coeffTableRegP6_1;
        end
      end
    end

  assign coeffNonZero = coeffTableReg6_1 != 17'sb00000000000000000;

  assign gainOut = 34'sh000000000;

  Addressable_Delay_Line_block9 u_delayLine0 (.clk(clk),
                                              .reset(reset),
                                              .enb(enb),
                                              .dataIn(dinSM),  // sfix17_En12
                                              .wrEn(delayLineValidInP),
                                              .delayLineEnd(delayLineEnd0)  // sfix17_En12
                                              );

  always @(posedge clk or posedge reset)
    begin : delayLineDataIn1_process
      if (reset == 1'b1) begin
        delayLineDataIn1_1 <= 17'sb00000000000000000;
      end
      else begin
        if (enb) begin
          delayLineDataIn1_1 <= delayLineEnd0;
        end
      end
    end

  Addressable_Delay_Line_block9 u_delayLine1 (.clk(clk),
                                              .reset(reset),
                                              .enb(enb),
                                              .dataIn(delayLineDataIn1_1),  // sfix17_En12
                                              .wrEn(delayLineShiftEn1_1),
                                              .delayLineEnd(delayLineEnd1)  // sfix17_En12
                                              );

  always @(posedge clk or posedge reset)
    begin : delayLineDataIn2_process
      if (reset == 1'b1) begin
        delayLineDataIn2_1 <= 17'sb00000000000000000;
      end
      else begin
        if (enb) begin
          delayLineDataIn2_1 <= delayLineEnd1;
        end
      end
    end

  Addressable_Delay_Line_block9 u_delayLine2 (.clk(clk),
                                              .reset(reset),
                                              .enb(enb),
                                              .dataIn(delayLineDataIn2_1),  // sfix17_En12
                                              .wrEn(delayLineShiftEn2_1),
                                              .delayLineEnd(delayLineEnd2)  // sfix17_En12
                                              );

  always @(posedge clk or posedge reset)
    begin : delayLineDataIn3_process
      if (reset == 1'b1) begin
        delayLineDataIn3_1 <= 17'sb00000000000000000;
      end
      else begin
        if (enb) begin
          delayLineDataIn3_1 <= delayLineEnd2;
        end
      end
    end

  Addressable_Delay_Line_block9 u_delayLine3 (.clk(clk),
                                              .reset(reset),
                                              .enb(enb),
                                              .dataIn(delayLineDataIn3_1),  // sfix17_En12
                                              .wrEn(delayLineShiftEn3_1),
                                              .delayLineEnd(delayLineEnd3)  // sfix17_En12
                                              );

  always @(posedge clk or posedge reset)
    begin : delayLineDataIn4_process
      if (reset == 1'b1) begin
        delayLineDataIn4_1 <= 17'sb00000000000000000;
      end
      else begin
        if (enb) begin
          delayLineDataIn4_1 <= delayLineEnd3;
        end
      end
    end

  Addressable_Delay_Line_block9 u_delayLine4 (.clk(clk),
                                              .reset(reset),
                                              .enb(enb),
                                              .dataIn(delayLineDataIn4_1),  // sfix17_En12
                                              .wrEn(delayLineShiftEn4_1),
                                              .delayLineEnd(delayLineEnd4)  // sfix17_En12
                                              );

  always @(posedge clk or posedge reset)
    begin : delayLineDataIn5_process
      if (reset == 1'b1) begin
        delayLineDataIn5_1 <= 17'sb00000000000000000;
      end
      else begin
        if (enb) begin
          delayLineDataIn5_1 <= delayLineEnd4;
        end
      end
    end

  Addressable_Delay_Line_block9 u_delayLine5 (.clk(clk),
                                              .reset(reset),
                                              .enb(enb),
                                              .dataIn(delayLineDataIn5_1),  // sfix17_En12
                                              .wrEn(delayLineShiftEn5_1),
                                              .delayLineEnd(delayLineEnd5)  // sfix17_En12
                                              );

  always @(posedge clk or posedge reset)
    begin : delayLineDataIn6_process
      if (reset == 1'b1) begin
        delayLineDataIn6_1 <= 17'sb00000000000000000;
      end
      else begin
        if (enb) begin
          delayLineDataIn6_1 <= delayLineEnd5;
        end
      end
    end

  Addressable_Delay_Line_block10 u_delayLine6 (.clk(clk),
                                               .reset(reset),
                                               .enb(enb),
                                               .dataIn(delayLineDataIn6_1),  // sfix17_En12
                                               .validIn(delayLineShiftEn6_1),
                                               .rdAddr(rdAddr6),  // ufix1
                                               .dataOut(delayLineDataOut6)  // sfix17_En12
                                               );

  assign gainOut_1 = {{2{delayLineDataOut6[16]}}, {delayLineDataOut6, 15'b000000000000000}};

  always @(posedge clk or posedge reset)
    begin : filterDelay_process
      if (reset == 1'b1) begin
        gainOutDB <= 34'sh000000000;
      end
      else begin
        if (enb) begin
          gainOutDB <= gainOut_1;
        end
      end
    end

  assign gainOutSwitch = (coeffNonZero == 1'b0 ? gainOut :
              gainOutDB);

  always @(posedge clk or posedge reset)
    begin : filterDelay_1_process
      if (reset == 1'b1) begin
        for(filterDelay_t_1 = 32'sd0; filterDelay_t_1 <= 32'sd3; filterDelay_t_1 = filterDelay_t_1 + 32'sd1) begin
          filterDelay_reg[filterDelay_t_1] <= 34'sh000000000;
        end
      end
      else begin
        if (enb) begin
          for(filterDelay_t_0_1 = 32'sd0; filterDelay_t_0_1 <= 32'sd3; filterDelay_t_0_1 = filterDelay_t_0_1 + 32'sd1) begin
            filterDelay_reg[filterDelay_t_0_1] <= filterDelay_reg_next[filterDelay_t_0_1];
          end
        end
      end
    end

  always @* begin
    gainOutREG = filterDelay_reg[3];
    filterDelay_reg_next[0] = gainOutSwitch;

    for(filterDelay_t_0_0 = 32'sd0; filterDelay_t_0_0 <= 32'sd2; filterDelay_t_0_0 = filterDelay_t_0_0 + 32'sd1) begin
      filterDelay_reg_next[filterDelay_t_0_0 + 32'sd1] = filterDelay_reg[filterDelay_t_0_0];
    end

  end

  assign sumOut_5 = gainOutREG[32:0];

  always @(posedge clk or posedge reset)
    begin : sumOutReg_process
      if (reset == 1'b1) begin
        sumOutReg_1 <= 33'sh000000000;
      end
      else begin
        if (enb) begin
          sumOutReg_1 <= sumOut_5;
        end
      end
    end

  assign accSwitchOut = (accumulate == 1'b0 ? accDataOut_1 :
              accDataOut);

  assign accAdderOut = accSwitchOut + sumOutReg_1;

  always @(posedge clk or posedge reset)
    begin : accDataOut_2_process
      if (reset == 1'b1) begin
        accDataOut_1 <= 33'sh000000000;
      end
      else begin
        if (enb) begin
          accDataOut_1 <= accAdderOut;
        end
      end
    end

  assign converterOut = {accDataOut_1[32], accDataOut_1};

  always @(posedge clk or posedge reset)
    begin : dout_re_process
      if (reset == 1'b1) begin
        dout_re_1 <= 34'sh000000000;
      end
      else begin
        if (enb && validOutLookahead_1) begin
          dout_re_1 <= converterOut;
        end
      end
    end

  assign dataZero = 34'sh000000000;

  assign subfilterOutTmp_2 = (notValid == 1'b0 ? dout_re_1 :
              dataZero);

  assign subfilterOutTmp_vld2 = vldOut_1;

endmodule  // FIRPartlySerial_block2

