// -------------------------------------------------------------
// 
// File Name: F:\MyGit_Folder\DRMTS_FunknerSchwarz\behav\Verilog\dsm_l2_sim_deci_cic_HDLgeneration\FirRdyLogic.v
// Created: 2026-01-30 10:39:16
// 
// Generated by MATLAB 25.2, HDL Coder 25.2, and Simulink 25.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: FirRdyLogic
// Source Path: dsm_l2_sim_deci_cic_HDLgeneration/DECIMATOR/HBF1/FIRPartlySerial/FirRdyLogic
// Hierarchy Level: 3
// Model version: 17.87
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module FirRdyLogic
          (clk,
           reset,
           enb,
           dinSwitch,
           dinVldSwitch,
           coeff,
           haltProcess,
           dinSM,
           dinVldSM);


  input   clk;
  input   reset;
  input   enb;
  input   signed [16:0] dinSwitch;  // sfix17_En13
  input   dinVldSwitch;
  input   signed [16:0] coeff;  // sfix17_En13
  input   haltProcess;
  output  signed [16:0] dinSM;  // sfix17_En13
  output  dinVldSM;


  wire syncReset;
  reg  firRdy_state;  // ufix1
  reg  firRdy_readyReg;
  reg  firRdy_count;  // ufix1
  reg  firRdy_state_next;  // ufix1
  reg  firRdy_readyReg_next;
  reg  firRdy_count_next;  // ufix1
  reg  readySM;
  reg signed [16:0] dinSM_1;  // sfix17_En13
  reg  dinVldSM_1;
  reg signed [16:0] coeffS;  // sfix17_En13
  reg  firRdy_out2_0;
  reg [1:0] firRdy_add_temp;  // ufix2
  reg [1:0] firRdy_t_0_0;  // ufix2


  assign syncReset = 1'b0;

  // rdyLogic
  always @(posedge clk or posedge reset)
    begin : firRdy_process
      if (reset == 1'b1) begin
        firRdy_state <= 1'b0;
        firRdy_readyReg <= 1'b1;
        firRdy_count <= 1'b0;
      end
      else begin
        if (enb) begin
          firRdy_state <= firRdy_state_next;
          firRdy_readyReg <= firRdy_readyReg_next;
          firRdy_count <= firRdy_count_next;
        end
      end
    end

  always @(coeff, dinSwitch, dinVldSwitch, firRdy_count, firRdy_readyReg, firRdy_state,
       haltProcess, syncReset) begin
    firRdy_add_temp = 2'b00;
    firRdy_t_0_0 = 2'b00;
    firRdy_count_next = firRdy_count;
    if (( ! haltProcess) && ( ! syncReset)) begin
      case ( firRdy_state)
        1'b0 :
          begin
            dinSM_1 = dinSwitch;
            firRdy_out2_0 = dinVldSwitch;
            coeffS = coeff;
            firRdy_state_next = 1'b0;
            firRdy_readyReg_next = 1'b1;
            if (dinVldSwitch) begin
              firRdy_state_next = 1'b1;
              firRdy_readyReg_next = 1'b0;
            end
          end
        1'b1 :
          begin
            firRdy_readyReg_next = 1'b1;
            firRdy_state_next = 1'b0;
            dinSM_1 = 17'sb00000000000000000;
            coeffS = 17'sb00000000000000000;
            firRdy_out2_0 = 1'b0;
          end
        default :
          begin
            dinSM_1 = 17'sb00000000000000000;
            firRdy_out2_0 = 1'b0;
            coeffS = 17'sb00000000000000000;
            firRdy_state_next = 1'b0;
            firRdy_readyReg_next = 1'b1;
          end
      endcase
    end
    else begin
      firRdy_state_next = 1'b0;
      firRdy_readyReg_next = 1'b0;
      dinSM_1 = 17'sb00000000000000000;
      firRdy_out2_0 = 1'b0;
      coeffS = 17'sb00000000000000000;
    end
    if ((dinVldSwitch || (firRdy_count > 1'b0)) || firRdy_out2_0) begin
      if ((( ~ firRdy_count) || haltProcess) || syncReset) begin
        firRdy_count_next = 1'b0;
      end
      else begin
        firRdy_t_0_0 = {1'b0, firRdy_count};
        firRdy_add_temp = firRdy_t_0_0 + 2'b01;
        firRdy_count_next = firRdy_add_temp[0];
      end
    end
    readySM = firRdy_readyReg;
    dinVldSM_1 = firRdy_out2_0;
  end

  assign dinSM = dinSM_1;

  assign dinVldSM = dinVldSM_1;

endmodule  // FirRdyLogic

