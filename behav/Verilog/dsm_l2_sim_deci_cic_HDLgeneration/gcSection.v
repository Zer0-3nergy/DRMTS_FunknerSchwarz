// -------------------------------------------------------------
// 
// File Name: F:\MyGit_Folder\DRMTS_FunknerSchwarz\behav\Verilog\dsm_l2_sim_deci_cic_HDLgeneration\gcSection.v
// Created: 2026-01-26 17:23:30
// 
// Generated by MATLAB 25.2, HDL Coder 25.2, and Simulink 25.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: gcSection
// Source Path: dsm_l2_sim_deci_cic_HDLgeneration/DECIMATOR/CICDecimation/gcSection
// Hierarchy Level: 2
// Model version: 17.86
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module gcSection
          (clk,
           reset,
           enb,
           combOut_re,
           combOut_im,
           internalReset,
           gcOut_re);


  input   clk;
  input   reset;
  input   enb;
  input   signed [17:0] combOut_re;  // sfix18_E5
  input   signed [17:0] combOut_im;  // sfix18_E5
  input   internalReset;
  output  signed [15:0] gcOut_re;  // sfix16_En14


  wire signed [15:0] bShift_re;  // sfix16_E7
  wire signed [36:0] bShiftreg_re;  // sfix37_En14
  wire signed [36:0] bRShift_re;  // sfix37_En14
  wire signed [15:0] coarseGtmpreg_re;  // sfix16_En14
  wire signed [15:0] bShift_im;  // sfix16_E7
  wire signed [36:0] bShiftreg_im;  // sfix37_En14
  wire signed [36:0] bRShift_im;  // sfix37_En14
  wire signed [15:0] coarseGtmpreg_im;  // sfix16_En14
  wire signed [22:0] fineMultreg;  // sfix23_En21
  reg signed [15:0] gainCorrection_gainDatareg2_re;  // sfix16
  reg signed [15:0] gainCorrection_gainDatareg1_im;  // sfix16
  reg signed [15:0] gainCorrection_gainDatareg2_im;  // sfix16
  reg signed [38:0] gainCorrection_gainOutareg1_re;  // sfix39
  reg signed [38:0] gainCorrection_gainOutareg1_im;  // sfix39
  reg signed [15:0] gainCorrection_gainDatareg1_re;  // sfix16
  wire signed [22:0] gainCorrection_fineGreg_tmp2;  // sfix23
  reg signed [38:0] mulOut_re;  // sfix39_En35
  reg signed [38:0] mulOut_im;  // sfix39_En35
  reg signed [38:0] intdelay_reg [0:2];  // sfix39 [3]
  reg signed [38:0] intdelay_reg_next [0:2];  // sfix39_En35 [3]
  reg signed [38:0] mulOutreg_re;  // sfix39_En35
  wire signed [15:0] gcOutreg_re;  // sfix16_En14
  reg signed [15:0] intdelay_reg_1 [0:1];  // sfix16 [2]
  wire signed [15:0] intdelay_reg_next_1 [0:1];  // sfix16_En14 [2]
  reg signed [31:0] intdelay_t_0_0;  // int32
  reg signed [31:0] intdelay_t_0_1;  // int32
  reg signed [31:0] intdelay_t_1;  // int32
  reg signed [31:0] intdelay_t_0_0_1;  // int32
  reg signed [31:0] intdelay_t_1_1;  // int32


  assign bShift_re = ((combOut_re[17] == 1'b0) && (combOut_re[16:2] == 15'b111111111111111) ? 16'sb0111111111111111 :
              combOut_re[17:2] + $signed({1'b0, combOut_re[1]}));

  assign bShiftreg_re = {bShift_re, 21'b000000000000000000000};

  assign bRShift_re = bShiftreg_re >>> 8'd21;

  assign coarseGtmpreg_re = ((bRShift_re[36] == 1'b0) && (bRShift_re[35:15] != 21'b000000000000000000000) ? 16'sb0111111111111111 :
              ((bRShift_re[36] == 1'b1) && (bRShift_re[35:15] != 21'b111111111111111111111) ? 16'sb1000000000000000 :
              $signed(bRShift_re[15:0])));

  assign bShift_im = ((combOut_im[17] == 1'b0) && (combOut_im[16:2] == 15'b111111111111111) ? 16'sb0111111111111111 :
              combOut_im[17:2] + $signed({1'b0, combOut_im[1]}));

  assign bShiftreg_im = {bShift_im, 21'b000000000000000000000};

  assign bRShift_im = bShiftreg_im >>> 8'd21;

  assign coarseGtmpreg_im = ((bRShift_im[36] == 1'b0) && (bRShift_im[35:15] != 21'b000000000000000000000) ? 16'sb0111111111111111 :
              ((bRShift_im[36] == 1'b1) && (bRShift_im[35:15] != 21'b111111111111111111111) ? 16'sb1000000000000000 :
              $signed(bRShift_im[15:0])));

  assign fineMultreg = 23'sb01000000000000000000000;

  always @(posedge clk or posedge reset)
    begin : gainCorrection_process
      if (reset == 1'b1) begin
        gainCorrection_gainDatareg1_re <= 16'sb0000000000000000;
        gainCorrection_gainDatareg1_im <= 16'sb0000000000000000;
        gainCorrection_gainDatareg2_re <= 16'sb0000000000000000;
        gainCorrection_gainDatareg2_im <= 16'sb0000000000000000;
        gainCorrection_gainOutareg1_re <= 39'sh0000000000;
        gainCorrection_gainOutareg1_im <= 39'sh0000000000;
        mulOut_re <= 39'sh0000000000;
        mulOut_im <= 39'sh0000000000;
      end
      else begin
        if (enb) begin
          if (internalReset == 1'b1) begin
            gainCorrection_gainDatareg1_re <= 16'sb0000000000000000;
            gainCorrection_gainDatareg1_im <= 16'sb0000000000000000;
            gainCorrection_gainDatareg2_re <= 16'sb0000000000000000;
            gainCorrection_gainDatareg2_im <= 16'sb0000000000000000;
            gainCorrection_gainOutareg1_re <= 39'sh0000000000;
            gainCorrection_gainOutareg1_im <= 39'sh0000000000;
            mulOut_re <= 39'sh0000000000;
            mulOut_im <= 39'sh0000000000;
          end
          else begin
            mulOut_re <= gainCorrection_gainOutareg1_re;
            mulOut_im <= gainCorrection_gainOutareg1_im;
            gainCorrection_gainDatareg1_re <= gainCorrection_gainDatareg2_re;
            gainCorrection_gainDatareg2_re <= coarseGtmpreg_re;
            gainCorrection_gainDatareg1_im <= gainCorrection_gainDatareg2_im;
            gainCorrection_gainDatareg2_im <= coarseGtmpreg_im;
            gainCorrection_gainOutareg1_re <= {{2{gainCorrection_gainDatareg1_re[15]}}, {gainCorrection_gainDatareg1_re, 21'b000000000000000000000}};
            gainCorrection_gainOutareg1_im <= {{2{gainCorrection_gainDatareg1_im[15]}}, {gainCorrection_gainDatareg1_im, 21'b000000000000000000000}};
          end
        end
      end
    end

  assign gainCorrection_fineGreg_tmp2 = fineMultreg;

  always @(posedge clk or posedge reset)
    begin : intdelay_process
      if (reset == 1'b1) begin
        for(intdelay_t_1 = 32'sd0; intdelay_t_1 <= 32'sd2; intdelay_t_1 = intdelay_t_1 + 32'sd1) begin
          intdelay_reg[intdelay_t_1] <= 39'sh0000000000;
        end
      end
      else begin
        if (enb) begin
          for(intdelay_t_0_1 = 32'sd0; intdelay_t_0_1 <= 32'sd2; intdelay_t_0_1 = intdelay_t_0_1 + 32'sd1) begin
            intdelay_reg[intdelay_t_0_1] <= intdelay_reg_next[intdelay_t_0_1];
          end
        end
      end
    end

  always @* begin
    mulOutreg_re = intdelay_reg[2];
    intdelay_reg_next[0] = mulOut_re;

    for(intdelay_t_0_0 = 32'sd0; intdelay_t_0_0 <= 32'sd1; intdelay_t_0_0 = intdelay_t_0_0 + 32'sd1) begin
      intdelay_reg_next[intdelay_t_0_0 + 32'sd1] = intdelay_reg[intdelay_t_0_0];
    end

  end

  assign gcOutreg_re = (((mulOutreg_re[38] == 1'b0) && (mulOutreg_re[37:36] != 2'b00)) || ((mulOutreg_re[38] == 1'b0) && (mulOutreg_re[36:21] == 16'sb0111111111111111)) ? 16'sb0111111111111111 :
              ((mulOutreg_re[38] == 1'b1) && (mulOutreg_re[37:36] != 2'b11) ? 16'sb1000000000000000 :
              mulOutreg_re[36:21] + $signed({1'b0, mulOutreg_re[20]})));

  always @(posedge clk or posedge reset)
    begin : intdelay_1_process
      if (reset == 1'b1) begin
        for(intdelay_t_1_1 = 32'sd0; intdelay_t_1_1 <= 32'sd1; intdelay_t_1_1 = intdelay_t_1_1 + 32'sd1) begin
          intdelay_reg_1[intdelay_t_1_1] <= 16'sb0000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(intdelay_t_0_0_1 = 32'sd0; intdelay_t_0_0_1 <= 32'sd1; intdelay_t_0_0_1 = intdelay_t_0_0_1 + 32'sd1) begin
            intdelay_reg_1[intdelay_t_0_0_1] <= intdelay_reg_next_1[intdelay_t_0_0_1];
          end
        end
      end
    end

  assign gcOut_re = intdelay_reg_1[1];
  assign intdelay_reg_next_1[0] = gcOutreg_re;
  assign intdelay_reg_next_1[1] = intdelay_reg_1[0];

endmodule  // gcSection

